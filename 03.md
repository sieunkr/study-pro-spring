
# 03. 스프링 IoC 와 DI 소개

# 3.1 IoC 와 DI

Ioc, DI 는 컴포넌트의 의존성을 제공하고 관리하는 기능을 제공한다. 

# 3.2 IoC 의 종류

IoC 의 종류
- 의존성 룩업 : 컴포넌트 스스로 의존성의 참조를 가져옴
- 의존성 주입 : IoC 컨테이너가 컴포넌트에 의존성을 주입

## 3.2.1 (의존성 룩업)의존성 풀

생략

````java	
//[https://github.com/Apress/pro-spring-5/blob/master/chapter03/dependency-pull/src/main/java/com/apress/prospring5/ch3/DependencyPull.java](https://github.com/Apress/pro-spring-5/blob/master/chapter03/dependency-pull/src/main/java/com/apress/prospring5/ch3/DependencyPull.java)
public static void main(String... args) {
	ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/app-context.xml");
	MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
	mr.render();
}
````

## 3.2.2 (의존성 룩업)문맥에 따른 의존성 룩업(???)

생략

## 3.2.3 생성자 의존성 주입

IoC 컨테이너는 해당 컴포넌트를 초기화할 때 컴포넌트에 필요한 의존성을 전달한다.

````java
//[https://github.com/Apress/pro-spring-5/blob/master/chapter03/constructor-injection/src/main/java/com/apress/prospring5/ch3/ConstructorInjection.java](https://github.com/Apress/pro-spring-5/blob/master/chapter03/constructor-injection/src/main/java/com/apress/prospring5/ch3/ConstructorInjection.java)
public class ConstructorInjection {
	private Dependency dependency;
	public ConstructorInjection(Dependency dependency) {
		this.dependency = dependency;
	}
	@Override
	public String toString() {
		return dependency.toString();
	}
}
````

## 3.2.4 Setter 의존성 주입

의존성 없이도 객체를 생성할 수 있고, 의존성을 나중에 제공할 수 있음.

````java
//[https://github.com/Apress/pro-spring-5/blob/master/chapter03/setter-injection/src/main/java/com/apress/prospring5/ch3/SetterInjection.java](https://github.com/Apress/pro-spring-5/blob/master/chapter03/setter-injection/src/main/java/com/apress/prospring5/ch3/SetterInjection.java)
public class SetterInjection {
	private Dependency dependency;
	public void setDependency(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
````


**[참고]의존성 주입 방법**
1. 필드 인젝션
2. 생성자 의존성 주입
3. 세터 의존성 주입
4. 롬복 라이브러리 사용

> 필드 인젝션 방식은 추후에 다시 다룰 예정

## 3.2.5 의존성 주입 vs 룩업

의존성 룩업은 필요한 의존성을 직접 가져와야 한다. 그리고 복잡하다. 

반면에, 의존성 주입은 협력 객체를 의존 객체에게 제공하는 IoC 컨테이너와 완전히 분리돼 자유롭게 사용할 수 있다.(?) 또한, 적절한 생성자나 Setter를 사용해 직접 테스트용 의존성을 쉽게 제공할 수도 있으므로 컴포넌트를 쉽게 테스트할 수 있다. 

자세한 내용은 생략. 88~89 page 확인


## 3.2.6 생성자 주입 vs Setter 주입

89~93 page


# 3.3 스프링의 IoC

스프링은 의존 객체에 협력 객체를 자동으로 제공하기 위해 의존성 주입을 이용한다. 


# 3.4 스프링의 의존성 주입

## 3.4.1 스프링의 의존성 주입 - Bean, BeanFactory

**BeanFactory**
컴포넌트 라이프사이클, 의존성 관리

**Bean**
컨테이너가 관리하는 모든 컴포넌트

95 페이지 무슨 내용인지 이해 안됨...

## 3.4.2 BeanFactory 구현체

~98 page

## 3.4.3 ApplicationContext

**스프링 ApplicationContext**
- BeanFactory 를 상속한 인터페이스
- 트랜잭션 서비스
- AOP
- 국제화(?)
- 이벤트 처리

등 여러 서비스를 제공한다. 스프링은 ApplicationContext 를 직접 코드로 부트스크랩(직접 인스턴스를 생성하고 적절한 애플리케이션 구성을 불러오는 방식) 또는 웹 컨테이너 환경에서 ContextLoaderListener를 이용해 부트스트랩한다. 


# 3.5 애플리케이션 컨텍스트 구성하기

## 3.5.1 스프링 구성 옵션 설정하기

- XML 기반
- 어노테이션 기반 자바 컨피그 구성

## 3.5.2 기본 구성 개요

**컴포넌트 스캔**
지정한 패키지의 모든 하위 패키지에 있는 클래스에 선언된 @Autowired, @Inject, @Resource, @Component, @Controller, @Service, @Repository 어노테이션이 선어된, 의존성 주입이 가능한 빈의 코드를 스캔하도록 스프링에 지시한다. 

**[참고]스프링부트에서의 컴포넌트 스캔**
main 클래스에 선언한 @SpringBootApplication 어노테이션에서 @ComponentScan 를 포함한다. 즉, 자동으로 컴포넌트 스캔을 실행한다.


## 3.5.3 컴포넌트 선언하기

**xml 정의 방식**
생략

**자바 어노테이션 기반 방식**

````java

@Component("provider")
public class HelloWorldMessageProvider implements MessageProvider {
	
}

@Service("renderer")
public class StandardOutMessageRenderer implements MessageRenderer {
	
	private MessageProvicer messageProvider;
	//생략
		
	@Autowired
	public void setMessageProvider(MessageProvider provider) {
		this.messageProvider = provider;
	}
	
}
````

컴포넌트 스캔을 사용해서, 컴포넌트를 찾아서 구성 파일에 지정한 이름으로 빈 인스턴스를 생성한다. 




#### 3.5.3.1 자바 구성 사용

````java
@Configuration
public class HelloWorldConfiguration {
	
	@Bean
	public MessageProvider provider() {
		return new...
	}
	
	생략
}
````


빈 이름은 해당 빈을 만드는데 사용된 메서드의 이름과 같다.(?) 

**[참고]빈 이름**
메서드의 이름과 같지만, 만약에 메서드가 대문자로 시작한다면, 소문자로 변경되어서 빈 네이밍이 결정된다. 또한, 별도의 이름을 설정할 수도 있다.

~108 페이지.. 무슨 내용인지 이해 안됨........ 나중에 다시 읽어보자


#### 3.5.3.2 Setter 주입 사용

**xml 방식**
property 사용

**java 어노테이션**

````java
public class ...
	private ...
	@Autowired
	public void setMessageProvider(MessageProvider provider) {
		this.messageProvider = provider
	}
````

컴포넌트 스캔으로 인해서, 스프링은 ApplicationContext 를 초기화하는 동안에, @Autowired 어노테이션을 발견하고 필요에 따라 의존성을 주입한다. 


#### 3.5.3.3 생성자 주입

````xml
<bean id="message" class="java.lang.String"...
````

````java
@Service
public class ConfigurableMessageProvider ...
	private String message;
	
	@Autowired
	public ConfigurableMessageProvider(String message) {
	}
````

나머지 내용 생략. ~118page 읽어보면 될 듯

**[참고]생성자 주입 시 Autowired 어노테이션 사용이 필수인가?**
필수로 선언하지 않아도 적용되는 것으로 알고 있는데... 스프링의 기능인지, 스프링부트의 기능인지 모르겠음. 추후 확인 필요..


#### 3.5.3.4 필드 주입

````java
@Service
public class ConfigurableMessageProvider ...
	
	@Autowired
	private MyCustomService service;

	//생략...
````

**필드 인젝션 사용 단점**

- 단일 책임 원칙을 위반하는 경우가 많음. 더 많은 의존성이 생기면 클래스에 대한 책임이 커지므로 리팩토링 시 관심사를 분리하기 어려울 수 있다. 
- 의존성 주입의 책임은 스프링 컨테이너에게 있지만, 클래스는 public 인터페이스의 메서드나 생성자르 ㄹ이용해 필요한 의존성 타입을 명확하게 전달해야 한다. 필드 주입을 사용하면 어떤 타입의 의존성이 실제로 필요한지, 의존성이 필수인지 여부가 명확하지 않을 수 있다.
- 필드 주입은 final 필드에 사용할 수 없다. 이 타입의 필드는 오직 생성자 주입만을 이용해 초기화할 수 있다.
- 필드 주입은 의존성을 수동으로 주입해야 하므로, 테스트 코드를 작성하기 어렵다. 


이후 내용... 책이 너무 재미 없어서.. 일단 패스하고, 나중에 다시 읽어볼 예정
121page ~ 146page


## 3.5.4 메서드 주입


 


























