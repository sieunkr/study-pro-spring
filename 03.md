
# 03. 스프링 IoC 와 DI 소개

# 3.1 IoC 와 DI

Ioc, DI 는 컴포넌트의 의존성을 제공하고 관리하는 기능을 제공한다. 

# 3.2 IoC 의 종류

IoC 의 종류
- 의존성 룩업 : 컴포넌트 스스로 의존성의 참조를 가져옴
- 의존성 주입 : IoC 컨테이너가 컴포넌트에 의존성을 주입

## 3.2.1 (의존성 룩업)의존성 풀

생략

````java	
//[https://github.com/Apress/pro-spring-5/blob/master/chapter03/dependency-pull/src/main/java/com/apress/prospring5/ch3/DependencyPull.java](https://github.com/Apress/pro-spring-5/blob/master/chapter03/dependency-pull/src/main/java/com/apress/prospring5/ch3/DependencyPull.java)
public static void main(String... args) {
	ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/app-context.xml");
	MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
	mr.render();
}
````

## 3.2.2 (의존성 룩업)문맥에 따른 의존성 룩업(???)

생략

## 3.2.3 생성자 의존성 주입

IoC 컨테이너는 해당 컴포넌트를 초기화할 때 컴포넌트에 필요한 의존성을 전달한다.

````java
//[https://github.com/Apress/pro-spring-5/blob/master/chapter03/constructor-injection/src/main/java/com/apress/prospring5/ch3/ConstructorInjection.java](https://github.com/Apress/pro-spring-5/blob/master/chapter03/constructor-injection/src/main/java/com/apress/prospring5/ch3/ConstructorInjection.java)
public class ConstructorInjection {
	private Dependency dependency;
	public ConstructorInjection(Dependency dependency) {
		this.dependency = dependency;
	}
	@Override
	public String toString() {
		return dependency.toString();
	}
}
````

## 3.2.4 Setter 의존성 주입

의존성 없이도 객체를 생성할 수 있고, 의존성을 나중에 제공할 수 있음.

````java
//[https://github.com/Apress/pro-spring-5/blob/master/chapter03/setter-injection/src/main/java/com/apress/prospring5/ch3/SetterInjection.java](https://github.com/Apress/pro-spring-5/blob/master/chapter03/setter-injection/src/main/java/com/apress/prospring5/ch3/SetterInjection.java)
public class SetterInjection {
	private Dependency dependency;
	public void setDependency(Dependency dependency) {
		this.dependency = dependency;
	}

	@Override
	public String toString() {
		return dependency.toString();
	}
}
````


**[참고]의존성 주입 방법**
1. 필드 인젝션
2. 생성자 의존성 주입
3. 세터 의존성 주입
4. 롬복 라이브러리 사용

> 필드 인젝션 방식은 추후에 다시 다룰 예정

## 3.2.5 의존성 주입 vs 룩업

의존성 룩업은 필요한 의존성을 직접 가져와야 한다. 그리고 복잡하다. 

반면에, 의존성 주입은 협력 객체를 의존 객체에게 제공하는 IoC 컨테이너와 완전히 분리돼 자유롭게 사용할 수 있다.(?) 또한, 적절한 생성자나 Setter를 사용해 직접 테스트용 의존성을 쉽게 제공할 수도 있으므로 컴포넌트를 쉽게 테스트할 수 있다. 

자세한 내용은 생략. 88~89 page 확인


## 3.2.6 생성자 주입 vs Setter 주입

89~93 page


# 3.3 스프링의 IoC

스프링은 의존 객체에 협력 객체를 자동으로 제공하기 위해 의존성 주입을 이용한다. 


# 3.4 스프링의 의존성 주입

## 3.4.1 스프링의 의존성 주입 - Bean, BeanFactory

**BeanFactory**
컴포넌트 라이프사이클, 의존성 관리

**Bean**
컨테이너가 관리하는 모든 컴포넌트

95 페이지 무슨 내용인지 이해 안됨...

## 3.4.2 BeanFactory 구현체

~98 page

## 3.4.3 ApplicationContext

**스프링 ApplicationContext**
- BeanFactory 를 상속한 인터페이스
- 트랜잭션 서비스
- AOP
- 국제화(?)
- 이벤트 처리

등 여러 서비스를 제공한다. 스프링은 ApplicationContext 를 직접 코드로 부트스크랩(직접 인스턴스를 생성하고 적절한 애플리케이션 구성을 불러오는 방식) 또는 웹 컨테이너 환경에서 ContextLoaderListener를 이용해 부트스트랩한다. 


# 3.5 애플리케이션 컨텍스트 구성하기

## 3.5.1 스프링 구성 옵션 설정하기

- XML 기반
- 어노테이션 기반 자바 컨피그 구성

## 3.5.2 기본 구성 개요

**컴포넌트 스캔**
지정한 패키지의 모든 하위 패키지에 있는 클래스에 선언된 @Autowired, @Inject, @Resource, @Component, @Controller, @Service, @Repository 어노테이션이 선어된, 의존성 주입이 가능한 빈의 코드를 스캔하도록 스프링에 지시한다. 

**[참고]스프링부트에서의 컴포넌트 스캔**
main 클래스에 선언한 @SpringBootApplication 어노테이션에서 @ComponentScan 를 포함한다. 즉, 자동으로 컴포넌트 스캔을 실행한다.


## 3.5.3 컴포넌트 선언하기

**xml 정의 방식**
생략

**자바 어노테이션 기반 방식**

````java

@Component("provider")
public class HelloWorldMessageProvider implements MessageProvider {
	
}

@Service("renderer")
public class StandardOutMessageRenderer implements MessageRenderer {
	
	private MessageProvicer messageProvider;
	//생략
		
	@Autowired
	public void setMessageProvider(MessageProvider provider) {
		this.messageProvider = provider;
	}
	
}
````

컴포넌트 스캔을 사용해서, 컴포넌트를 찾아서 구성 파일에 지정한 이름으로 빈 인스턴스를 생성한다. 




























